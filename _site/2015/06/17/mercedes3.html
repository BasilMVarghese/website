<!DOCTYPE html>
<html class="no-js">
  <head>
	<meta charset="utf-8">
	<title><i>GSoC,</i> Symbolic planning techniques for recognizing objects domestic <p>#3</p> | RoboComp</title>
	<meta name="description" content="Visual inverse kinematics, Basic understanding : In the previous post we anticipate the problems caused by the gaps and inaccuracies of motors in the inverse...">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-Frame-Options" content="sameorigin">

	<!-- CSS -->
	<link rel="stylesheet" href="/website/css/main.css">

	<!--Favicon-->
	<link rel="shortcut icon" href="/website/favicon.ico" type="image/x-icon">

	<!-- Canonical -->
	<link rel="canonical" href="http://robocomp.github.io/website/2015/06/17/mercedes3.html">

	<!-- RSS -->
	<link rel="alternate" type="application/atom+xml" title="RoboComp" href="http://robocomp.github.io/website/feed.xml" />

	<!-- Font Awesome -->
	<link href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet">

	<!-- Google Fonts -->
	
	<link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700,700italic,400italic" rel="stylesheet" type="text/css">
	

	<!-- KaTeX -->
	
	<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/KaTeX/0.3.0/katex.min.css">
	<script src="//cdnjs.cloudflare.com/ajax/libs/KaTeX/0.3.0/katex.min.js"></script>
	

	<!-- Google Analytics -->
	
	<script>
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	ga('create', 'UA-37388407-1', 'auto');
	ga('send', 'pageview');
	</script>
	
</head>

  <body>
    <header class="site-header">
	<div class="branding">
		
		<a href="/website/">
			<img class="avatar" src="/website/img/avatar.png" alt=""/>
		</a>
		
		<h1 class="site-title">
			<a href="/website/">RoboComp</a>
		</h1>
	</div>
	<nav class="site-nav">
		<ul>
			
			
			
			
			<li>
				
				<a class="page-link" href="/website/Blog/">
					Blog
				</a> &nbsp;&nbsp;·&nbsp;&nbsp;
			</li>
			
			
			
			<li>
				
				<a class="page-link" href="/website/GSoC/">
					GSoC
				</a> &nbsp;&nbsp;·&nbsp;&nbsp;
			</li>
			
			
			
			<li>
				
				<a class="page-link" href="/website/projects/">
					Projects
				</a> &nbsp;&nbsp;·&nbsp;&nbsp;
			</li>
			
			
			
			<li>
				
				<a class="page-link" href="/website/Tutorials/">
					Tutorials
				</a> &nbsp;&nbsp;·&nbsp;&nbsp;
			</li>
			
			
			
			<li>
				
				<a class="page-link" href="/website/about/">
					About
				</a> &nbsp;&nbsp;·&nbsp;&nbsp;
			</li>
			
			
			
			<li>
				
				<a class="page-link" href="/website/contact/">
					Contact
				</a> &nbsp;&nbsp;·&nbsp;&nbsp;
			</li>
			
			
			
			
			
			
			
			<li>
				
				<a class="page-link" href="/website/install/">
					Install
				</a> &nbsp;&nbsp;·&nbsp;&nbsp;
			</li>
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			<!-- Social icons from Font Awesome, if enabled -->
			














<li>
	<a href="https://github.com/robocomp" title="Follow on GitHub">
		<i class="fa fa-fw fa-github"></i>
	</a>
</li>


























		</ul>
	</nav>
</header>

    <div class="content">
      <article >
  <header style="background-image: url('/website/')">
    <h1 class="title"><i>GSoC,</i> Symbolic planning techniques for recognizing objects domestic <p>#3</p></h1>
    <p class="meta">
    June 17, 2015
    
    </p>
  </header>
  <section class="post-content"><p><strong>Visual inverse kinematics, Basic understanding :</strong> In the previous post we anticipate the problems caused by the gaps and inaccuracies of motors in the inverse kinematics of the robot. Now, in this third post we will talk about the solution implemented during the GSoC15 project.</p>

<p>So, with the inverse kinematics component that we have implemented in Robocomp, we had the problem of inaccuracies and gaps in the robotic arm motors, problems that made the robot believed reach the target position without having actually achieved it. To solve this problem it was decided to implement a solution inside the visual field (which is what concerns us throughout this project), whose aim is to provide the inverse kinematics component a visual feedback that allows correct its mistakes. The operation of the algorithm is very simple and takes as its starting point the investigations of Seth Hutchinson, Greg Hager and Peter Corke, collected in <code>A Tutorial on Visual Servo Control</code> [1].</p>

<h2 id="looking-then-moving">‘Looking’, then ‘moving’</h2>

<p>As Hutchinson, Hager and Corke reflect in their work:</p>

<blockquote>
  <p>Vision is a useful robotic sensor since it mimics the human sense of vision and allows for non-contact measurement of the environment. […] Typically visual sensing and manipulation are combined in a open-loop fashion, ‘looking’ then ‘moving’.</p>
</blockquote>

<p>So the goal of <code>Visual servo control</code> is to control the movement and location of the robot using visual techniques (detection and recognition of objects in an image). To get an idea how it works, we must have clear some fundamental concepts in this field</p>

<h3 id="kinematics-of-a-robot">Kinematics of a robot</h3>

<p>We need to know what a kinematic chain is, what reference system and transformation coordinate are anda what algorithm is executed inside the robot kinematic. These concepts were explained in the second post of this collection. If you have doubts, consult it.</p>

<p>If we link the kinematic chains concept with visual techniques (ie, now, in addition to the chain formed by the motors of the robotic arm, we have a camera in the chain looking one of the chain ends), we have two types of systems:</p>

<ol>
  <li>Endpoint open-loop (EOL): Systems which only observed the target object. These systems don’t need to look at his end effector so normally the camera is on the end effector (hand-eye).</li>
  <li>Endpoint closed-loop (ECL): Systems which observed the target object and the end effector of the arm.</li>
</ol>

<p>The visual inverse kinematics that we implemented in Robocomp uses this last configuration because is independent of hand-eye calibration errors (precisely, the clearances errors and inaccuracies that bother us in the inverse kinematics), although often requires solution of a more demanding vision problem, because we need to track the end effector.</p>

<h3 id="camera-projection-models">Camera Projection Models</h3>

<p>We need to understand the geometric aspects of the imaging process if we want to understand how the information provided by the vision system is used to control the movement of the robot. The first thing to consider is that an image taken by a camera is always in 2D, so we’re losing spatial information (the depth of the scene).</p>

<p><img src="http://masters.donntu.org/2012/etf/nikitin/library/article10.files/image10.01.png" alt="Alt text" /></p>

<p>To resolve this issue we have several options:
1. We can use multiple cameras that capture the studio space from different positions.
2. We can obtain multiple views with a single camera.
3. We can have previously stored the geometric relationship between certain characteristics of the target or the elements in the studio space.</p>

<p>In any case, we must keep in mind certain things common to all cameras. For example the system of axes: the <code>X</code> and <code>Y</code> axes form the basis of the image plane and the <code>Z</code> axis is perpendicular to the image plane, along the optical axis of the camera. The origin is located on the <code>Z</code> axis at a distance <code>λ</code> of the image plane. That distance <code>λ</code> is what we call focal length.</p>

<p><img src="http://www.hitl.washington.edu/artoolkit/documentation/images/ch03-17.gif" alt="ALt text" /></p>

<p>We can map the position and the orientation of the end effector in space calculating the projective geometry of the camera. But this method, complicated in itself, increases their difficulty because we need <code>recognize</code> the end effector in the picture, in addition to deriving the speed from the changes observed in each frame that the camera capture. For these reasons, in our visual inverse kinematic component, we use the algorithm proposed by Edwin Olson, <code>Apriltags</code> [2] a visual fiducial system that uses a 2D barcode style <code>tag</code> (binary, black and white synthetic brands), allowing full 6 DOF localization of features from a single image. Thus, if we put a apriltag in the end effector, we can get its position and orientation in a very simple way.</p>

<h2 id="visualbik-component">visualBIK component</h2>

<p>Having already some clear concepts, let us study how the component developed in this project, <code>visualBIK</code>, works.</p>

<p>Our component implements a simple state machine where waits the reception of a target position (a vector with traslations and rotations: [tx, ty, tz,    rx, ry, rz]) through its interface. When a target is received, the visualBIK send it to the inverse kinematics component like a <code>POSE6D</code> target, and waits for him to finish running the target and placing the arm. As the end effector will be a little out of the target position (due to inaccuracies), the visualBIK will be prepared to correct this error:</p>

<ol>
  <li>It calculates the visual pose of the end effector (through apriltags, visualBIK receives the position of the end effector mark that the camera head sees).</li>
  <li>After, it compute the error vector between the visual pose and the target pose.</li>
  <li>With this error vector, visualBIK corrects the target pose and sends the new position to the inverse kinematics component.</li>
  <li>This process is repeated until the error achieved in translation and rotation is less than a predetermined threshold.</li>
</ol>

<p>In this way we can correct the errors introduced by the inaccuracies of the joints.</p>

<p>This component (like component inverse kinematics) is still in the testing phase and is more than likely suffer some changes that improve its operation.</p>

<p>Bye!</p>

<hr />
<p>[1] Hutchinson, S., Hager, G., Corke, P. <code>A Tutorial on Visual Servo Control</code>, IEEE Trans. Robot. Automat., 12(5):651–670, Oct. 1996. Download in http://www-cvr.ai.uiuc.edu/~seth/ResPages/pdfs/HutHagCor96.pdf</p>

<p>[2] OLson, E. <code>AprilTag: A robust and flexible visual fiducial system</code>, Robotics and Automation (ICRA), 2011 IEEE International Conference on, 3400-3407</p>
</section>
</article>

<!-- Post navigation -->


<!-- Disqus -->


    </div>
    <script src="/website/js/main.js"></script>


<footer class="site-footer">
	<p class="text">Copyright <a href="http://robocomp.github.io">RoboComp</a>
</p>
</footer>


  </body>
</html>
